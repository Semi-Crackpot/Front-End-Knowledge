# 守卫

### 守卫的作用
1.  进行权限判断

### 安装
1.  安装守卫：``nest g guard guard/auth``，守卫放在src/guard目录中，auth是守卫名称

### 守卫文件解析
    ```ts
    import { CanActivate, ExecutionContext, Injectable } from '@nestjs/common';
    import { Observable } from 'rxjs';
    @Injectable()
    // 守卫必须实现 CanActivate接口
    export class AuthGuard implements CanActivate {
        // 守卫必须实现 canActivate方法
        canActivate(
            // 参数context
            context: ExecutionContext,
        // 返回值是boolean类型
        ): boolean | Promise<boolean> | Observable<boolean> {
            return true;
        }
    }
    ```

### 使用守卫，根据权限判断路由是否可以访问
1.  在守卫文件导出的类中，返回一个Boolean值
    ```ts
    export class AuthGuard implements CanActivate {
        canActivate(
            context: ExecutionContext,
        ): boolean | Promise<boolean> | Observable<boolean> {
            // 如果返回true，则路由可以访问；如果为false，则路由无法访问
            return true;
        }
    }
2.  在控制器文件配置路由时，使用守卫装饰对应的路由
    ```ts
    @Get()
    @UseGuards(AuthGuard)
    index(): string {
        return '我是admin模块中的用户页面'
    }
    // 如果无法访问，返回403状态码
3.  也可以在整个控制器上，使用守卫
    ```ts
    @Controller('admin/user')
    // 守卫会作用于，该控制器配置的所有路由
    @UseGuards(AuthGuard)
    export class UserController {
        @Get()
        index(): string {
            return '我是admin模块中的用户页面'
        }
    }

### 全局使用守卫
- 在入口文件``main.ts``中，引入并配置全局守卫
    ```ts
    import { AuthGuard } from './guard/auth.guard'
    app.useGlobalGuards(new AuthGuard());

### 根据cookie和session进行权限判断
1.  首先，设置cookie或session（我们这里设置session）
    ```ts
    @Controller('admin/login')
    export class LoginController {
        @Get()
        index(@Request() req): string {
            // 设置session
            req.session.username = 'zhangsan'
            return '登录成功'
        }
    }
2.  在守卫中，根据session进行权限判断，我们首先了解一下``context.switchToHttp().getRequest()``的信息
    ```ts
    const req = context.switchToHttp().getRequest();
    console.log(req); // 打印结果是一个对象
    ```
    - 该对象有三个重要属性，可以帮助我们进行权限判断
    ```ts
    // 因为我们没有设置cookie，所以此时cookie为空对象
    cookies: [Object: null prototype] {},
    // 通过 context.switchToHttp().getRequest().session 可以获取我们设置好的session
    session: Session {
        cookie: {
            path: '/',
            _expires: 2020-05-30T04:37:53.331Z,
            originalMaxAge: 60000,
            httpOnly: true
        }
    },
    // 通过 context.switchToHttp().getRequest().path 可以决定哪些路由页面不进行权限判断，直接显示
    route: Route {
        path: '/admin/login',
        stack: [ [Layer] ],
        methods: { get: true }
    }
3.  接下来，我们就根据设置好的session，对某些特定路由页面进行权限判断
    ```ts
    @Injectable()
    export class AuthGuard implements CanActivate {
        canActivate(
            context: ExecutionContext,
        ): boolean | Promise<boolean> | Observable<boolean> {
            const req = context.switchToHttp().getRequest();
            // 如果路由是 /admin/login，即登录页面，则直接显示，不进行权限判断
            if(req.path == '/admin/login') {
                return true;
            // 否则
            } else {
                // 获取设置好的session中的username
                const userInfo = context.switchToHttp().getRequest().session.username;
                // 如果session存在，即已经登录
                if(userInfo) {
                    // 则显示路由页面
                    return true
                // 如果不存在，即还未登录
                } else {
                    // 就不显示路由页面
                    return false
                }
            }
        }
    }

### 在模块（根模块或子模块）中配置守卫
    ```ts
    import { AuthGuard } from '../../guard/auth.guard'
    import { APP_GUARD } from '@nestjs/core';
    @Module({
        providers: [
            {
                provide: APP_GUARD,
                useClass: AuthGuard
            }
        ]
    })
    export class AdminModule {}
    ```

### 
