# 文件上传

### 单个文件上传
1.  需求：在浏览器页面的表单中，上传文件，服务器可以接收到文件，并保存到静态文件目录中
2.  首先创建一个含有表单的EJS模板文件``default/upload.ts``
    ```html
    <!-- 注意，必须添加属性 enctype="multipart/form-data"，否则无法保存文件到服务器 -->
    <form action="/upload/doAdd" method="post" enctype="multipart/form-data">
        <!-- 文本表单 -->
        <input type="text" name="username">
        <br>
        <!-- 文件提交表单 -->
        <input type="file" name="pic">
        <br>
        <input type="submit" value="提交">
    </form>
3.  在控制器中设置一个路由，渲染该表单模板文件
    ```ts
    @Get()
    @Render('default/upload')
    index(): any {
        return {}
    }
4.  在控制器中设置另一个路由，将表单提交的文件，保存到静态文件目录``public/upload``中
    ```ts
    // 引入UseInterceptors装饰器，UploadedFile装饰器
    import { UseInterceptors, UploadedFile } from '@nestjs/common';
    // 引入FileInterceptor拦截器
    import { FileInterceptor } from '@nestjs/platform-express';
    // 引入createWriteStream，即写入流
    import { createWriteStream } from 'fs';
    // 引入join方法，用于拼接文件要写入到的路径以及文件名
    import { join } from 'path';
    @Post('doAdd')
    // 拦截器FileInterceptor的参数，必须与文件提交表单的name属性值相同
    @UseInterceptors(FileInterceptor('pic'))
    // Body装饰器获取文本表单提交的内容，UploadedFile装饰器获取文件提交表单提交的文件
    doAdd(@Body() body, @UploadedFile() file): string {
        console.log(body); // {username: 'xxx'}，是一个对象
        console.log(file); // { fieldname: 'pic', originalname: '上传的文件名', buffer: 文件的buffer值}，是一个对象
        // 创建写入流，将上传文件写入到拼接成的目标文件中，使用模板字符串设置目标文件名
        const writeStream = createWriteStream(join(__dirname, '../../public/upload', `${file.originalname}`));
        // 使用write方法，将文件的buffer值写入到目标文件中
        writeStream.write(file.buffer);
        return '上传文件成功';
    }

### 多个文件上传
1.  需求：在浏览器页面的表单中，上传多个文件，服务器可以接收到文件，并保存到静态文件目录中
2.  在控制器中设置另一个路由，将表单提交的文件，保存到静态文件目录``public/upload``中
    ```ts
    // 注意，这里引入的是UploadedFiles，而不是UploadedFile
    import { UseInterceptors, UploadedFiles } from '@nestjs/common';
    // 注意，这里引入的是FilesInterceptor，而不是FileInterceptor
    import { FilesInterceptor } from '@nestjs/platform-express';
    @Post('doAdd')
    @UseInterceptors(FilesInterceptor('pic'))
    doAdd(@Body() body, @UploadedFiles() files): string {
        console.log(body);
        console.log(files); // [{第一个上传文件的信息}, {第二个上传文件的信息}, ...]，是一个数组
        // 对所有上传文件的数组进行循环遍历
        for(const file of files) {
            const writeStream = createWriteStream(join(__dirname, '../../public/upload', `${file.originalname}`));
            writeStream.write(file.buffer);
        }
        return '上传文件成功';
    }
3.  ``FilesInterceptor拦截器``的参数的区别
    - 如果每个文件提交表单的``name属性值相同``
        ```html
        <input type="file" name="pic">
        <input type="file" name="pic">
        ```
        - 则参数``写成这个name属性值``
        ```ts
        @UseInterceptors(FilesInterceptor('pic'))
    - 如果每个文件提交表单的``name属性值不同``
        ```html
        <input type="file" name="userinfo">
        <input type="file" name="userpic">
        ```
        - 则参数``写成数组形式``
        ```ts
        @UseInterceptors(FilesInterceptor([
            // maxCount是name对应的文件提交表单的个数
            { name: 'userinfo', maxCount: 1 }
            { name: 'userpic', maxCount: 1}
        ]))

### 