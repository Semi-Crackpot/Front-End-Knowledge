# 装饰器

### 什么是装饰器？
- 装饰器就是一个方法，用来扩展类、属性、方法、参数

### 类装饰器
- 类装饰器，用于给要装饰的类的原型添加属性和方法
    ```ts
    // 定义类装饰器，参数target是要装饰的类的原型对象
    function logClass(target: any) {
        // 给类的原型添加属性
        target.prototype.url = 'xxx';
        // 给类的原型添加方法
        target.prototype.run = function() {
            console.log('yyy');
        }
    }
    // 使用装饰器，装饰Person类
    @logClass
    class Person {}
    // 类实例化，类型要与装饰器中的参数的指定类型相同
    var p: any = new Person();
    console.log(p.url);
    p.run();

### 类装饰器的替换功能
    ```ts
    function logClass(target: any) {
        // 返回继承自被装饰的类的子类
        return class extends target {
            // 替换装饰类的属性
            url: any = 'xxx';
            // 替换装饰类的方法
            getData() {
                console.log(this.url);
            }
        }
    }
    // 使用装饰器
    @logClass
    class Person {
        url: string | undefined;
        constructor() {
            this.url = 'yyy';
        }
        getData() {};
    }
    var p: any = new Person();
    p.getData(); // xxx
    ```

### 属性装饰器
- 将参数作为属性值，传递给类的属性
    ```ts
    // params是要传给类的属性的属性值
    function logProperty(params: any) {
        // target：对于静态成员，是类的构造函数；对于实例成员，是类的原型对象
        // attr是要装饰的属性
        return function(target: any, attr: any) {
            // 将params赋给类的属性
            target[attr] = params;
        }
    }
    class Person {
        // 使用装饰器
        @logProperty('baidu.com')
        url: any | undefined;
        constructor() {};
        getData() {
            console.log(this.url);
        }
    }
    var p: any = new Person();
    p.getData(); // baidu.com

### 装饰器工厂
- 将参数作为属性值，给要装饰的类的原型添加属性
    ```ts
    // 参数params，作为属性值，传递给类原型链上的属性
    function logClass(params: string) {
        // 返回一个函数，参数target是要装饰的类
        return function(target: any) {
            // 把params传给类的原型的属性url
            target.prototype.url = params;
        }
    }
    // 使用装饰器
    @logClass('baidu.com')
    class Person {}
    var p: any = new Person();
    console.log(p.url);

### 方法装饰器
- 修改要装饰的方法，例如需求：``将原方法中传入的参数都转化为String类型``
    ```ts
    function logMethod(params: any) {
        // target：对于静态成员，是类的构造函数；对于实例成员，是类的原型对象
        // methodName是装饰的方法名
        // desc是装饰的方法的信息，其中desc.value指向方法
        return function(target: any, methodName: any, desc: any) {
            // 先保存装饰的方法
            var oMethod = desc.value;
            // 修改方法
            desc.value = function(...args: any[]) {
                // 将传入的参数都变成字符串
                args = args.map(item => {
                    return String(item)
                })
                // 执行保存的原来装饰的方法，使用修改后的参数args
                oMethod.apply(this, args);
            }
        }
    }
    class HttpClient {
        url: any | undefined;
        constructor() {};
        // 使用装饰器，参数任意
        @logMethod('aaa')
        getData(...args: any[]) {
            console.log(args);
        }
    }
    var h = new HttpClient();
    h.getData(1, 232);

### 多个装饰器的执行顺序
- 属性装饰器 -> 方法装饰器 -> 类装饰器
- 从后到前、从下到上执行

### 