# 排序算法：https://juejin.im/post/5ab62ec36fb9a028cf326c49

### swap函数封装
  ```js
  function swap(arr, index1, index2) {
    [arr[index1], arr[index2]] = [arr[index2], arr[index1]]
  }
  ```

### 冒泡排序
1.  排序思想：每一轮前后元素依次比较，将最大的数排到最后
2.  时间复杂度：O(n^2)
3.  实现（双向遍历优化）
  ```js
  function bubbleSort(arr) {
    let left = 0, right = arr.length - 1
    while(left < right) {
      for(let i = left; i < right; i++) {
        if(arr[i] > arr[i + 1]) {
          swap(arr, i, i + 1)
        }
      }
      right--
      for(let i = right; i > left; i--) {
        if(arr[i] < arr[i - 1]) {
          swap(arr, i, i - 1)
        }
      }
      left++
    }
    return arr
  }
  ```
4.  扩展（传入第二个参数，来控制升序和降序）
  ```js
  function bubbleSort(arr, rule) {
    for(let i = arr.length - 1; i > 0; i--) {
      for(let j = 0; j < i; j++) {
        if(rule(arr[j], arr[j + 1]) > 0) {
          swap(arr, j, j + 1)
        }
      }
    }
    return arr
  }
  ```

### 选择排序
1.  排序思想：每一次内循环遍历寻找最小的数，记录下minIndex，在内循环结束后，交换minIndex与i的位置
2.  时间复杂度：O(n^2)
3.  实现（找到最小值，并交换到数组的头部）
  ```js
  function selectSort(arr) {
    for(let i = 0; i < arr.length - 1; i++) {
      let minIndex = i
      for(let j = i + 1; j < arr.length; j++) {
        if(arr[j] < arr[minIndex]) {
          minIndex = j
        }
      }
      if(i != minIndex) {
        swap(arr, i, minIndex)
      }
    }
    return arr
  }
  ```
4.  另一种实现（找到最大值，并交换到数组的尾部）
  ```js
  function selectSort(arr) {
    for(let i = arr.length - 1; i > 0; i--) {
      let maxIndex = i
      for(let j = i - 1; j >= 0; j--) {
        if(arr[j] > arr[maxIndex]) {
          maxIndex = j
        }
      }
      if(i != maxIndex) {
        swap(arr, i, maxIndex)
      }
    }
    return arr
  }
  ```

### 插入排序
1.  排序思想：默认arr[0]为已排序数组中的元素，从arr[1]开始，往数组中插入元素
2.  时间复杂度：O(n^2)
3.  实现（先封装二分查找，找到要插入的位置，再封装插入排序）
  ```js
  // 二分查找
  function binarySearch(arr, maxIndex, value) {
    let left = 0, right = maxIndex
    while(left <= right) {
      let mid = Math.floor((left + right) / 2)
      if(arr[mid] <= value) {
        left = mid + 1
      } else {
        right = mid - 1
      }
    }
    return left
  }
  // 插入排序
  function insertSort(arr) {
    for(let i = 1; i < arr.length; i++) {
      let temp = arr[i]
      let insertIndex = binarySearch(arr, i - 1, arr[i])
      for(let j = i - 1; j >= insertIndex; j--) {
        arr[j + 1] = arr[j]
      }
      arr[insertIndex] = temp
    }
    return arr
  }
  ```

### 快速排序
1.  排序思想：
  - 从数组中挑出一个元素，作为基准元素(pivot)
  - 所有比基准值小的元素，放在基准元素前面；比基准值大的元素，放在基准元素后面
  - 递归地对小于基准元素的子数组和大于基准元素的子数组进行排序
2.  时间复杂度：O(nlogn)
3.  实现（选取第一个元素作为基准元素）
  ```js
  const partition = (arr, left, right) => {
    let pivot = left, 
        index = pivot + 1;
    for (let i = index; i <= right; i++) {
        if (arr[i] < arr[pivot]) {
            swap(arr, i, index);
            index++;
        }
    }
    swap(arr, pivot, index - 1);
    return index - 1;
  };
  const quickSort = (arr, left = 0, right = arr.length - 1) => {
    if (left < right) {
        partitionIndex = partition(arr, left, right);
        quickSort(arr, left, partitionIndex - 1);
        quickSort(arr, partitionIndex + 1, right);
    }
  };
  ```

### 