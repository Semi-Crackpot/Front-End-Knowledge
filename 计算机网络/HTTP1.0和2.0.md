# HTTP1.0和2.0：https://juejin.im/post/6844904072080801806

### HTTP1.1存在的问题
1.  线头阻塞：TCP连接只能发送一个请求
2.  请求并发：虽然HTTP1.1管线化可以支持请求并发，但浏览器很难实现，chrome等都禁用了管线化，所以1.1的请求并发依赖于多个TCP连接
3.  头部冗余：采用文本格式，首部未压缩，并且每个请求都会带上cookie、user-agent等完全相同的首部
4.  客户端需要主动请求

### HTTP2.0的改进
1.  二进制分帧层：一条HTTP响应，划分成两个帧来传输，并且采用二进制来编码
  - 1.1 响应是文本格式，而 2.0 把响应划分成两个帧（首部 HEADERS 和消息负载 DATA）
2.  多路复用：所有的通信都在一个TCP连接上完成，真正实现了请求的并发
  - HTTP2.0 建立一个TCP连接，一个连接上面可以有任意多个流，消息分割成一个或多个帧在流里面传输
  - 帧传输过去以后，再进行重组，形成一个完整的请求或响应，这使得所有的请求或响应都无法阻塞
3.  头部压缩
  - 在 1.x 版本中，首部用文本格式传输，通常会给每个传输增加一些字节的开销
  - 现在打开一个网页，上百个请求已经是常态，而每个请求带的一些首部字段都是相同的，比如 cookie、user-agent 等等
  - HTTP2.0 采用 HPACK 压缩格式来压缩首部，头部压缩需要在浏览器和服务器之间维护一份相同的静态字典和一份相同的动态字典
  - 在传输首部字段时，例如要传输 Method：GET，只需要传输静态字典里面 Method：GET 对于的索引值即可，一个字节搞定
  - 而像 cookie、user-agent 这种静态字典里面只有首部名称没有值的字段，第一次传输需要在静态字典的索引以及它的值，之后会把它添加到动态字典中，后续就可以传输索引即可
4.  服务器端推送：使得服务器可以预测客户端需要的资源，主动推送到客户端
  - 客户端发出页面请求时，服务器端能够分析这个页面所依赖的其他资源，主动推送到客户端的缓存，当客户端收到原始网页的请求时，它需要的资源已经位于缓存

### 搭建 HTTP2.0 的服务器
- http://nodejs.cn/api/http2.html